/**\n * Bundle Analyzer - Utilitários para análise de bundle\n * Análise de tamanho, dependências e otimizações\n */\n\n// === INTERFACES ===\nexport interface BundleStats {\n  /** Tamanho total do bundle (bytes) */\n  totalSize: number;\n  /** Tamanho comprimido (gzip) */\n  gzipSize: number;\n  /** Tamanho comprimido (brotli) */\n  brotliSize?: number;\n  /** Chunks do bundle */\n  chunks: ChunkInfo[];\n  /** Assets do bundle */\n  assets: AssetInfo[];\n  /** Dependências */\n  dependencies: DependencyInfo[];\n  /** Métricas de performance */\n  performance: PerformanceMetrics;\n}\n\nexport interface ChunkInfo {\n  /** Nome do chunk */\n  name: string;\n  /** Tamanho em bytes */\n  size: number;\n  /** Tamanho comprimido */\n  gzipSize: number;\n  /** Módulos incluídos */\n  modules: string[];\n  /** Se é um chunk de entrada */\n  isEntry: boolean;\n  /** Se é um chunk inicial */\n  isInitial: boolean;\n  /** Chunks que este chunk importa */\n  imports: string[];\n  /** Chunks que importam este chunk */\n  importedBy: string[];\n}\n\nexport interface AssetInfo {\n  /** Nome do asset */\n  name: string;\n  /** Tipo do asset */\n  type: 'js' | 'css' | 'image' | 'font' | 'other';\n  /** Tamanho em bytes */\n  size: number;\n  /** Se é crítico para o carregamento inicial */\n  critical: boolean;\n}\n\nexport interface DependencyInfo {\n  /** Nome da dependência */\n  name: string;\n  /** Versão */\n  version: string;\n  /** Tamanho em bytes */\n  size: number;\n  /** Porcentagem do bundle total */\n  percentage: number;\n  /** Se é uma dependência de desenvolvimento */\n  isDev: boolean;\n  /** Chunks que usam esta dependência */\n  usedInChunks: string[];\n}\n\nexport interface PerformanceMetrics {\n  /** Tempo estimado de carregamento (3G) */\n  loadTime3G: number;\n  /** Tempo estimado de carregamento (4G) */\n  loadTime4G: number;\n  /** Tempo estimado de carregamento (WiFi) */\n  loadTimeWiFi: number;\n  /** Score de performance (0-100) */\n  performanceScore: number;\n  /** Recomendações de otimização */\n  recommendations: string[];\n}\n\n// === CONSTANTES ===\nconst NETWORK_SPEEDS = {\n  '3G': 1.6 * 1024 * 1024 / 8, // 1.6 Mbps em bytes/s\n  '4G': 10 * 1024 * 1024 / 8,  // 10 Mbps em bytes/s\n  'WiFi': 50 * 1024 * 1024 / 8, // 50 Mbps em bytes/s\n};\n\nconst SIZE_THRESHOLDS = {\n  CHUNK_WARNING: 250 * 1024,    // 250KB\n  CHUNK_ERROR: 500 * 1024,      // 500KB\n  TOTAL_WARNING: 1024 * 1024,   // 1MB\n  TOTAL_ERROR: 2 * 1024 * 1024, // 2MB\n};\n\n// === CLASSE PRINCIPAL ===\nexport class BundleAnalyzer {\n  private stats: BundleStats | null = null;\n\n  // Analisar bundle a partir de stats do webpack/rollup\n  analyzeFromStats(statsData: any): BundleStats {\n    const chunks = this.parseChunks(statsData);\n    const assets = this.parseAssets(statsData);\n    const dependencies = this.parseDependencies(statsData);\n    \n    const totalSize = assets.reduce((sum, asset) => sum + asset.size, 0);\n    const gzipSize = Math.round(totalSize * 0.3); // Estimativa\n    \n    const performance = this.calculatePerformanceMetrics(totalSize, gzipSize, chunks);\n    \n    this.stats = {\n      totalSize,\n      gzipSize,\n      chunks,\n      assets,\n      dependencies,\n      performance,\n    };\n    \n    return this.stats;\n  }\n\n  // Analisar bundle atual no browser\n  analyzeCurrentBundle(): BundleStats {\n    const scripts = Array.from(document.querySelectorAll('script[src]'));\n    const stylesheets = Array.from(document.querySelectorAll('link[rel=\"stylesheet\"]'));\n    const images = Array.from(document.querySelectorAll('img[src]'));\n    \n    const assets: AssetInfo[] = [];\n    \n    // Analisar scripts\n    scripts.forEach((script: HTMLScriptElement) => {\n      if (script.src) {\n        assets.push({\n          name: this.extractFilename(script.src),\n          type: 'js',\n          size: 0, // Não podemos obter o tamanho real no browser\n          critical: script.hasAttribute('defer') || script.hasAttribute('async') ? false : true,\n        });\n      }\n    });\n    \n    // Analisar CSS\n    stylesheets.forEach((link: HTMLLinkElement) => {\n      if (link.href) {\n        assets.push({\n          name: this.extractFilename(link.href),\n          type: 'css',\n          size: 0,\n          critical: !link.media || link.media === 'all',\n        });\n      }\n    });\n    \n    // Analisar imagens\n    images.forEach((img: HTMLImageElement) => {\n      if (img.src) {\n        assets.push({\n          name: this.extractFilename(img.src),\n          type: 'image',\n          size: 0,\n          critical: img.loading !== 'lazy',\n        });\n      }\n    });\n    \n    const totalSize = 0; // Não podemos calcular no browser\n    const performance = this.calculatePerformanceMetrics(totalSize, 0, []);\n    \n    this.stats = {\n      totalSize,\n      gzipSize: 0,\n      chunks: [],\n      assets,\n      dependencies: [],\n      performance,\n    };\n    \n    return this.stats;\n  }\n\n  // Parse chunks do stats\n  private parseChunks(statsData: any): ChunkInfo[] {\n    if (!statsData.chunks) return [];\n    \n    return statsData.chunks.map((chunk: any) => ({\n      name: chunk.name || chunk.id,\n      size: chunk.size || 0,\n      gzipSize: Math.round((chunk.size || 0) * 0.3),\n      modules: chunk.modules?.map((m: any) => m.name || m.id) || [],\n      isEntry: chunk.entry || false,\n      isInitial: chunk.initial || false,\n      imports: chunk.children || [],\n      importedBy: chunk.parents || [],\n    }));\n  }\n\n  // Parse assets do stats\n  private parseAssets(statsData: any): AssetInfo[] {\n    if (!statsData.assets) return [];\n    \n    return statsData.assets.map((asset: any) => {\n      const name = asset.name;\n      const size = asset.size || 0;\n      \n      let type: AssetInfo['type'] = 'other';\n      if (name.endsWith('.js')) type = 'js';\n      else if (name.endsWith('.css')) type = 'css';\n      else if (/\\.(png|jpg|jpeg|gif|svg|webp)$/i.test(name)) type = 'image';\n      else if (/\\.(woff|woff2|ttf|eot|otf)$/i.test(name)) type = 'font';\n      \n      return {\n        name,\n        type,\n        size,\n        critical: type === 'js' || type === 'css',\n      };\n    });\n  }\n\n  // Parse dependências\n  private parseDependencies(statsData: any): DependencyInfo[] {\n    // Esta função dependeria do formato específico dos stats\n    // Por enquanto, retorna array vazio\n    return [];\n  }\n\n  // Calcular métricas de performance\n  private calculatePerformanceMetrics(\n    totalSize: number, \n    gzipSize: number, \n    chunks: ChunkInfo[]\n  ): PerformanceMetrics {\n    const effectiveSize = gzipSize || totalSize;\n    \n    const loadTime3G = effectiveSize / NETWORK_SPEEDS['3G'];\n    const loadTime4G = effectiveSize / NETWORK_SPEEDS['4G'];\n    const loadTimeWiFi = effectiveSize / NETWORK_SPEEDS['WiFi'];\n    \n    // Calcular score de performance (0-100)\n    let score = 100;\n    \n    // Penalizar por tamanho total\n    if (effectiveSize > SIZE_THRESHOLDS.TOTAL_ERROR) {\n      score -= 40;\n    } else if (effectiveSize > SIZE_THRESHOLDS.TOTAL_WARNING) {\n      score -= 20;\n    }\n    \n    // Penalizar por chunks grandes\n    const largeChunks = chunks.filter(chunk => chunk.size > SIZE_THRESHOLDS.CHUNK_ERROR);\n    score -= largeChunks.length * 10;\n    \n    // Penalizar por muitos chunks pequenos\n    const smallChunks = chunks.filter(chunk => chunk.size < 10 * 1024); // < 10KB\n    if (smallChunks.length > 10) {\n      score -= 15;\n    }\n    \n    score = Math.max(0, Math.min(100, score));\n    \n    const recommendations = this.generateRecommendations(effectiveSize, chunks);\n    \n    return {\n      loadTime3G,\n      loadTime4G,\n      loadTimeWiFi,\n      performanceScore: score,\n      recommendations,\n    };\n  }\n\n  // Gerar recomendações de otimização\n  private generateRecommendations(totalSize: number, chunks: ChunkInfo[]): string[] {\n    const recommendations: string[] = [];\n    \n    // Recomendações baseadas no tamanho total\n    if (totalSize > SIZE_THRESHOLDS.TOTAL_ERROR) {\n      recommendations.push('Bundle muito grande (>2MB). Considere code splitting mais agressivo.');\n    } else if (totalSize > SIZE_THRESHOLDS.TOTAL_WARNING) {\n      recommendations.push('Bundle grande (>1MB). Considere lazy loading para rotas não críticas.');\n    }\n    \n    // Recomendações baseadas em chunks\n    const largeChunks = chunks.filter(chunk => chunk.size > SIZE_THRESHOLDS.CHUNK_ERROR);\n    if (largeChunks.length > 0) {\n      recommendations.push(`${largeChunks.length} chunk(s) muito grande(s). Considere dividir em chunks menores.`);\n    }\n    \n    const smallChunks = chunks.filter(chunk => chunk.size < 10 * 1024);\n    if (smallChunks.length > 10) {\n      recommendations.push('Muitos chunks pequenos. Considere agrupar chunks relacionados.');\n    }\n    \n    // Recomendações gerais\n    if (recommendations.length === 0) {\n      recommendations.push('Bundle otimizado! Considere implementar service worker para cache.');\n    }\n    \n    return recommendations;\n  }\n\n  // Extrair nome do arquivo da URL\n  private extractFilename(url: string): string {\n    return url.split('/').pop()?.split('?')[0] || url;\n  }\n\n  // Gerar relatório detalhado\n  generateReport(): string {\n    if (!this.stats) {\n      return 'Nenhuma análise disponível. Execute analyzeFromStats() ou analyzeCurrentBundle() primeiro.';\n    }\n    \n    const { totalSize, gzipSize, chunks, assets, performance } = this.stats;\n    \n    let report = '# Bundle Analysis Report\\n\\n';\n    \n    // Resumo geral\n    report += '## Resumo Geral\\n';\n    report += `- **Tamanho Total**: ${this.formatBytes(totalSize)}\\n`;\n    report += `- **Tamanho Comprimido**: ${this.formatBytes(gzipSize)}\\n`;\n    report += `- **Chunks**: ${chunks.length}\\n`;\n    report += `- **Assets**: ${assets.length}\\n`;\n    report += `- **Score de Performance**: ${performance.performanceScore}/100\\n\\n`;\n    \n    // Tempos de carregamento\n    report += '## Tempos de Carregamento Estimados\\n';\n    report += `- **3G**: ${performance.loadTime3G.toFixed(2)}s\\n`;\n    report += `- **4G**: ${performance.loadTime4G.toFixed(2)}s\\n`;\n    report += `- **WiFi**: ${performance.loadTimeWiFi.toFixed(2)}s\\n\\n`;\n    \n    // Chunks maiores\n    const largestChunks = chunks\n      .sort((a, b) => b.size - a.size)\n      .slice(0, 5);\n    \n    if (largestChunks.length > 0) {\n      report += '## Maiores Chunks\\n';\n      largestChunks.forEach((chunk, index) => {\n        report += `${index + 1}. **${chunk.name}**: ${this.formatBytes(chunk.size)}\\n`;\n      });\n      report += '\\n';\n    }\n    \n    // Assets por tipo\n    const assetsByType = assets.reduce((acc, asset) => {\n      acc[asset.type] = (acc[asset.type] || 0) + asset.size;\n      return acc;\n    }, {} as Record<string, number>);\n    \n    report += '## Assets por Tipo\\n';\n    Object.entries(assetsByType).forEach(([type, size]) => {\n      report += `- **${type.toUpperCase()}**: ${this.formatBytes(size)}\\n`;\n    });\n    report += '\\n';\n    \n    // Recomendações\n    if (performance.recommendations.length > 0) {\n      report += '## Recomendações\\n';\n      performance.recommendations.forEach((rec, index) => {\n        report += `${index + 1}. ${rec}\\n`;\n      });\n    }\n    \n    return report;\n  }\n\n  // Gerar relatório JSON\n  generateJSONReport(): string {\n    return JSON.stringify(this.stats, null, 2);\n  }\n\n  // Formatar bytes para leitura humana\n  private formatBytes(bytes: number): string {\n    if (bytes === 0) return '0 B';\n    \n    const k = 1024;\n    const sizes = ['B', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    \n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  }\n\n  // Comparar com análise anterior\n  compareWith(previousStats: BundleStats): {\n    sizeDiff: number;\n    chunksDiff: number;\n    performanceDiff: number;\n    improvements: string[];\n    regressions: string[];\n  } {\n    if (!this.stats) {\n      throw new Error('No current stats available');\n    }\n    \n    const sizeDiff = this.stats.totalSize - previousStats.totalSize;\n    const chunksDiff = this.stats.chunks.length - previousStats.chunks.length;\n    const performanceDiff = this.stats.performance.performanceScore - previousStats.performance.performanceScore;\n    \n    const improvements: string[] = [];\n    const regressions: string[] = [];\n    \n    if (sizeDiff < 0) {\n      improvements.push(`Tamanho reduzido em ${this.formatBytes(Math.abs(sizeDiff))}`);\n    } else if (sizeDiff > 0) {\n      regressions.push(`Tamanho aumentado em ${this.formatBytes(sizeDiff)}`);\n    }\n    \n    if (performanceDiff > 0) {\n      improvements.push(`Score de performance melhorou ${performanceDiff.toFixed(1)} pontos`);\n    } else if (performanceDiff < 0) {\n      regressions.push(`Score de performance piorou ${Math.abs(performanceDiff).toFixed(1)} pontos`);\n    }\n    \n    return {\n      sizeDiff,\n      chunksDiff,\n      performanceDiff,\n      improvements,\n      regressions,\n    };\n  }\n}\n\n// === FUNÇÕES DE CONVENIÊNCIA ===\n\n// Analisar bundle atual\nexport const analyzeCurrentBundle = (): BundleStats => {\n  const analyzer = new BundleAnalyzer();\n  return analyzer.analyzeCurrentBundle();\n};\n\n// Gerar relatório rápido\nexport const generateQuickReport = (): string => {\n  const analyzer = new BundleAnalyzer();\n  const stats = analyzer.analyzeCurrentBundle();\n  return analyzer.generateReport();\n};\n\n// Verificar se bundle está otimizado\nexport const isBundleOptimized = (): boolean => {\n  const stats = analyzeCurrentBundle();\n  return stats.performance.performanceScore >= 80;\n};\n\n// Obter recomendações de otimização\nexport const getOptimizationRecommendations = (): string[] => {\n  const stats = analyzeCurrentBundle();\n  return stats.performance.recommendations;\n};\n\n// === TIPOS EXPORTADOS ===\nexport type {\n  BundleStats,\n  ChunkInfo,\n  AssetInfo,\n  DependencyInfo,\n  PerformanceMetrics,\n};"