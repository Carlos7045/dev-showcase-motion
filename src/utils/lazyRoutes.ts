/**\n * LazyRoutes - Sistema de lazy loading para rotas\n * Code splitting estrat√©gico para otimiza√ß√£o de performance\n */\n\nimport { lazy, ComponentType } from 'react';\n\n// === INTERFACES ===\nexport interface LazyRouteConfig {\n  /** Chave √∫nica da rota */\n  key: string;\n  /** Fun√ß√£o de importa√ß√£o */\n  importFn: () => Promise<{ default: ComponentType<any> }>;\n  /** Se deve fazer preload */\n  preload?: boolean;\n  /** Prioridade de carregamento */\n  priority?: 'high' | 'medium' | 'low';\n  /** Depend√™ncias que devem ser carregadas junto */\n  dependencies?: string[];\n}\n\nexport interface RouteChunk {\n  /** Nome do chunk */\n  name: string;\n  /** Rotas inclu√≠das no chunk */\n  routes: string[];\n  /** Tamanho estimado (KB) */\n  estimatedSize?: number;\n  /** Se √© um chunk cr√≠tico */\n  critical?: boolean;\n}\n\n// === CACHE DE COMPONENTES ===\nconst componentCache = new Map<string, ComponentType<any>>();\nconst loadingPromises = new Map<string, Promise<{ default: ComponentType<any> }>>();\nconst preloadedRoutes = new Set<string>();\n\n// === CONFIGURA√á√ÉO DE ROTAS LAZY ===\nexport const LAZY_ROUTES: Record<string, LazyRouteConfig> = {\n  // P√°ginas principais (alta prioridade)\n  home: {\n    key: 'home',\n    importFn: () => import('@/pages/Home'),\n    preload: true,\n    priority: 'high',\n  },\n  about: {\n    key: 'about',\n    importFn: () => import('@/pages/About'),\n    preload: true,\n    priority: 'high',\n  },\n  \n  // Blog (m√©dia prioridade)\n  blog: {\n    key: 'blog',\n    importFn: () => import('@/pages/Blog'),\n    priority: 'medium',\n  },\n  blogPost: {\n    key: 'blogPost',\n    importFn: () => import('@/pages/BlogPost'),\n    priority: 'medium',\n    dependencies: ['blog'],\n  },\n  \n  // Projetos (m√©dia prioridade)\n  projects: {\n    key: 'projects',\n    importFn: () => import('@/pages/Projects'),\n    priority: 'medium',\n  },\n  projectDetail: {\n    key: 'projectDetail',\n    importFn: () => import('@/pages/ProjectDetail'),\n    priority: 'medium',\n    dependencies: ['projects'],\n  },\n  \n  // Contato (baixa prioridade)\n  contact: {\n    key: 'contact',\n    importFn: () => import('@/pages/Contact'),\n    priority: 'low',\n  },\n  \n  // Admin (baixa prioridade, carregamento sob demanda)\n  admin: {\n    key: 'admin',\n    importFn: () => import('@/pages/Admin'),\n    priority: 'low',\n  },\n  adminDashboard: {\n    key: 'adminDashboard',\n    importFn: () => import('@/pages/AdminDashboard'),\n    priority: 'low',\n    dependencies: ['admin'],\n  },\n  \n  // P√°ginas de erro\n  notFound: {\n    key: 'notFound',\n    importFn: () => import('@/pages/NotFound'),\n    priority: 'low',\n  },\n  error: {\n    key: 'error',\n    importFn: () => import('@/pages/Error'),\n    priority: 'low',\n  },\n};\n\n// === CONFIGURA√á√ÉO DE CHUNKS ===\nexport const ROUTE_CHUNKS: RouteChunk[] = [\n  {\n    name: 'core',\n    routes: ['home', 'about'],\n    critical: true,\n    estimatedSize: 150,\n  },\n  {\n    name: 'blog',\n    routes: ['blog', 'blogPost'],\n    estimatedSize: 100,\n  },\n  {\n    name: 'projects',\n    routes: ['projects', 'projectDetail'],\n    estimatedSize: 120,\n  },\n  {\n    name: 'secondary',\n    routes: ['contact'],\n    estimatedSize: 50,\n  },\n  {\n    name: 'admin',\n    routes: ['admin', 'adminDashboard'],\n    estimatedSize: 200,\n  },\n  {\n    name: 'errors',\n    routes: ['notFound', 'error'],\n    estimatedSize: 30,\n  },\n];\n\n// === CLASSE PARA GERENCIAR LAZY ROUTES ===\nexport class LazyRouteManager {\n  private static instance: LazyRouteManager;\n  private preloadQueue: string[] = [];\n  private isPreloading = false;\n\n  static getInstance(): LazyRouteManager {\n    if (!LazyRouteManager.instance) {\n      LazyRouteManager.instance = new LazyRouteManager();\n    }\n    return LazyRouteManager.instance;\n  }\n\n  // Criar componente lazy\n  createLazyComponent(routeKey: string): ComponentType<any> {\n    const config = LAZY_ROUTES[routeKey];\n    if (!config) {\n      throw new Error(`Route config not found for key: ${routeKey}`);\n    }\n\n    // Verificar cache\n    if (componentCache.has(routeKey)) {\n      return componentCache.get(routeKey)!;\n    }\n\n    // Criar componente lazy\n    const LazyComponent = lazy(() => {\n      // Verificar se j√° existe uma promise de carregamento\n      if (loadingPromises.has(routeKey)) {\n        return loadingPromises.get(routeKey)!;\n      }\n\n      // Criar nova promise de carregamento\n      const loadPromise = config.importFn().then(module => {\n        // Cache do componente\n        componentCache.set(routeKey, module.default);\n        loadingPromises.delete(routeKey);\n        \n        console.log(`‚úÖ Loaded route: ${routeKey}`);\n        return module;\n      }).catch(error => {\n        loadingPromises.delete(routeKey);\n        console.error(`‚ùå Failed to load route: ${routeKey}`, error);\n        throw error;\n      });\n\n      loadingPromises.set(routeKey, loadPromise);\n      return loadPromise;\n    });\n\n    // Cache do componente lazy\n    componentCache.set(routeKey, LazyComponent);\n    return LazyComponent;\n  }\n\n  // Preload de rota\n  async preloadRoute(routeKey: string): Promise<void> {\n    const config = LAZY_ROUTES[routeKey];\n    if (!config || preloadedRoutes.has(routeKey)) {\n      return;\n    }\n\n    try {\n      preloadedRoutes.add(routeKey);\n      \n      // Preload depend√™ncias primeiro\n      if (config.dependencies) {\n        await Promise.all(\n          config.dependencies.map(dep => this.preloadRoute(dep))\n        );\n      }\n\n      // Preload da rota\n      const module = await config.importFn();\n      componentCache.set(routeKey, module.default);\n      \n      console.log(`üöÄ Preloaded route: ${routeKey}`);\n    } catch (error) {\n      preloadedRoutes.delete(routeKey);\n      console.warn(`‚ö†Ô∏è Failed to preload route: ${routeKey}`, error);\n    }\n  }\n\n  // Preload m√∫ltiplas rotas\n  async preloadRoutes(routeKeys: string[]): Promise<void> {\n    const preloadPromises = routeKeys.map(key => this.preloadRoute(key));\n    await Promise.allSettled(preloadPromises);\n  }\n\n  // Preload por prioridade\n  async preloadByPriority(priority: 'high' | 'medium' | 'low'): Promise<void> {\n    const routesToPreload = Object.values(LAZY_ROUTES)\n      .filter(config => config.priority === priority && config.preload !== false)\n      .map(config => config.key);\n\n    await this.preloadRoutes(routesToPreload);\n  }\n\n  // Preload de chunk\n  async preloadChunk(chunkName: string): Promise<void> {\n    const chunk = ROUTE_CHUNKS.find(c => c.name === chunkName);\n    if (!chunk) {\n      console.warn(`Chunk not found: ${chunkName}`);\n      return;\n    }\n\n    await this.preloadRoutes(chunk.routes);\n  }\n\n  // Preload inteligente baseado na rota atual\n  async intelligentPreload(currentRoute: string): Promise<void> {\n    if (this.isPreloading) return;\n    \n    this.isPreloading = true;\n    \n    try {\n      // Preload rotas relacionadas\n      const relatedRoutes = this.getRelatedRoutes(currentRoute);\n      await this.preloadRoutes(relatedRoutes);\n      \n      // Preload pr√≥ximas rotas prov√°veis\n      const likelyNextRoutes = this.getLikelyNextRoutes(currentRoute);\n      await this.preloadRoutes(likelyNextRoutes);\n      \n    } finally {\n      this.isPreloading = false;\n    }\n  }\n\n  // Obter rotas relacionadas\n  private getRelatedRoutes(currentRoute: string): string[] {\n    const config = LAZY_ROUTES[currentRoute];\n    if (!config) return [];\n\n    const related: string[] = [];\n    \n    // Adicionar depend√™ncias\n    if (config.dependencies) {\n      related.push(...config.dependencies);\n    }\n    \n    // Adicionar rotas que dependem da atual\n    Object.values(LAZY_ROUTES).forEach(otherConfig => {\n      if (otherConfig.dependencies?.includes(currentRoute)) {\n        related.push(otherConfig.key);\n      }\n    });\n    \n    return related;\n  }\n\n  // Obter pr√≥ximas rotas prov√°veis\n  private getLikelyNextRoutes(currentRoute: string): string[] {\n    // L√≥gica baseada em padr√µes de navega√ß√£o\n    const navigationPatterns: Record<string, string[]> = {\n      home: ['about', 'projects', 'blog'],\n      about: ['contact', 'projects'],\n      blog: ['blogPost'],\n      projects: ['projectDetail', 'contact'],\n      contact: ['home'],\n    };\n\n    return navigationPatterns[currentRoute] || [];\n  }\n\n  // Preload on idle\n  preloadOnIdle(): void {\n    if ('requestIdleCallback' in window) {\n      requestIdleCallback(() => {\n        this.preloadByPriority('high');\n      });\n      \n      requestIdleCallback(() => {\n        this.preloadByPriority('medium');\n      }, { timeout: 5000 });\n    } else {\n      // Fallback para browsers sem requestIdleCallback\n      setTimeout(() => {\n        this.preloadByPriority('high');\n      }, 1000);\n      \n      setTimeout(() => {\n        this.preloadByPriority('medium');\n      }, 3000);\n    }\n  }\n\n  // Limpar cache\n  clearCache(): void {\n    componentCache.clear();\n    loadingPromises.clear();\n    preloadedRoutes.clear();\n  }\n\n  // Obter estat√≠sticas\n  getStats(): {\n    cached: number;\n    preloaded: number;\n    loading: number;\n    totalRoutes: number;\n  } {\n    return {\n      cached: componentCache.size,\n      preloaded: preloadedRoutes.size,\n      loading: loadingPromises.size,\n      totalRoutes: Object.keys(LAZY_ROUTES).length,\n    };\n  }\n\n  // Verificar se rota est√° carregada\n  isRouteLoaded(routeKey: string): boolean {\n    return componentCache.has(routeKey);\n  }\n\n  // Verificar se rota est√° sendo carregada\n  isRouteLoading(routeKey: string): boolean {\n    return loadingPromises.has(routeKey);\n  }\n}\n\n// === FUN√á√ïES DE CONVENI√äNCIA ===\n\n// Inst√¢ncia singleton\nexport const lazyRouteManager = LazyRouteManager.getInstance();\n\n// Criar componente lazy\nexport const createLazyRoute = (routeKey: string) => {\n  return lazyRouteManager.createLazyComponent(routeKey);\n};\n\n// Preload de rota\nexport const preloadRoute = (routeKey: string) => {\n  return lazyRouteManager.preloadRoute(routeKey);\n};\n\n// Preload m√∫ltiplas rotas\nexport const preloadRoutes = (routeKeys: string[]) => {\n  return lazyRouteManager.preloadRoutes(routeKeys);\n};\n\n// Hook para preload inteligente\nexport const useIntelligentPreload = (currentRoute: string) => {\n  React.useEffect(() => {\n    lazyRouteManager.intelligentPreload(currentRoute);\n  }, [currentRoute]);\n};\n\n// Hook para preload on idle\nexport const usePreloadOnIdle = () => {\n  React.useEffect(() => {\n    lazyRouteManager.preloadOnIdle();\n  }, []);\n};\n\n// Configurar preload baseado em hover\nexport const setupHoverPreload = () => {\n  document.addEventListener('mouseover', (event) => {\n    const target = event.target as HTMLElement;\n    const link = target.closest('a[data-preload]');\n    \n    if (link) {\n      const routeKey = link.getAttribute('data-preload');\n      if (routeKey) {\n        preloadRoute(routeKey);\n      }\n    }\n  });\n};\n\n// Configurar preload baseado em intersection\nexport const setupIntersectionPreload = () => {\n  const observer = new IntersectionObserver((entries) => {\n    entries.forEach(entry => {\n      if (entry.isIntersecting) {\n        const routeKey = entry.target.getAttribute('data-preload');\n        if (routeKey) {\n          preloadRoute(routeKey);\n          observer.unobserve(entry.target);\n        }\n      }\n    });\n  }, {\n    rootMargin: '100px',\n  });\n\n  // Observar elementos com data-preload\n  document.querySelectorAll('[data-preload]').forEach(el => {\n    observer.observe(el);\n  });\n\n  return observer;\n};\n\n// === TIPOS EXPORTADOS ===\nexport type { LazyRouteConfig, RouteChunk };"