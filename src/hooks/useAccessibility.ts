/**
 * useAccessibility - Hooks para funcionalidades de acessibilidade
 * Navegação por teclado, ARIA, focus management e screen readers
 */

import { useEffect, useRef, useCallback, useState } from 'react';

// === TIPOS ===
export interface KeyboardNavigationOptions {
  /** Se deve capturar teclas de seta */
  enableArrowKeys?: boolean;
  /** Se deve capturar Enter/Space */
  enableActionKeys?: boolean;
  /** Se deve capturar Escape */
  enableEscapeKey?: boolean;
  /** Se deve fazer loop na navegação */
  enableLoop?: boolean;
  /** Callback para teclas de seta */
  onArrowKey?: (direction: 'up' | 'down' | 'left' | 'right') => void;
  /** Callback para Enter/Space */
  onAction?: () => void;
  /** Callback para Escape */
  onEscape?: () => void;
}

export interface FocusManagementOptions {
  /** Se deve restaurar foco ao fechar */
  restoreFocus?: boolean;
  /** Se deve fazer trap do foco */
  trapFocus?: boolean;
  /** Seletor para elementos focáveis */
  focusableSelector?: string;
  /** Se deve focar automaticamente */
  autoFocus?: boolean;
}

export interface ScreenReaderOptions {
  /** Se deve anunciar mudanças */
  announceChanges?: boolean;
  /** Tipo de região ARIA */
  ariaLive?: 'polite' | 'assertive' | 'off';
  /** Se deve usar aria-atomic */
  atomic?: boolean;
}

// === HOOK PARA NAVEGAÇÃO POR TECLADO ===
export const useKeyboardNavigation = (options: KeyboardNavigationOptions = {}) => {
  const {
    enableArrowKeys = true,
    enableActionKeys = true,
    enableEscapeKey = true,
    enableLoop = false,
    onArrowKey,
    onAction,
    onEscape,
  } = options;

  const handleKeyDown = useCallback((event: KeyboardEvent) => {
    // Teclas de seta
    if (enableArrowKeys && onArrowKey) {\n      switch (event.key) {\n        case 'ArrowUp':\n          event.preventDefault();\n          onArrowKey('up');\n          break;\n        case 'ArrowDown':\n          event.preventDefault();\n          onArrowKey('down');\n          break;\n        case 'ArrowLeft':\n          event.preventDefault();\n          onArrowKey('left');\n          break;\n        case 'ArrowRight':\n          event.preventDefault();\n          onArrowKey('right');\n          break;\n      }\n    }\n\n    // Teclas de ação\n    if (enableActionKeys && onAction) {\n      if (event.key === 'Enter' || event.key === ' ') {\n        event.preventDefault();\n        onAction();\n      }\n    }\n\n    // Tecla Escape\n    if (enableEscapeKey && onEscape && event.key === 'Escape') {\n      event.preventDefault();\n      onEscape();\n    }\n  }, [enableArrowKeys, enableActionKeys, enableEscapeKey, onArrowKey, onAction, onEscape]);\n\n  useEffect(() => {\n    document.addEventListener('keydown', handleKeyDown);\n    return () => document.removeEventListener('keydown', handleKeyDown);\n  }, [handleKeyDown]);\n\n  return { handleKeyDown };\n};\n\n// === HOOK PARA GERENCIAMENTO DE FOCO ===\nexport const useFocusManagement = (options: FocusManagementOptions = {}) => {\n  const {\n    restoreFocus = true,\n    trapFocus = false,\n    focusableSelector = 'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])',\n    autoFocus = false,\n  } = options;\n\n  const containerRef = useRef<HTMLElement>(null);\n  const previousFocusRef = useRef<HTMLElement | null>(null);\n  const [focusableElements, setFocusableElements] = useState<HTMLElement[]>([]);\n  const [currentFocusIndex, setCurrentFocusIndex] = useState(0);\n\n  // Encontrar elementos focáveis\n  const updateFocusableElements = useCallback(() => {\n    if (!containerRef.current) return;\n\n    const elements = Array.from(\n      containerRef.current.querySelectorAll(focusableSelector)\n    ) as HTMLElement[];\n\n    const visibleElements = elements.filter(el => {\n      const style = window.getComputedStyle(el);\n      return (\n        style.display !== 'none' &&\n        style.visibility !== 'hidden' &&\n        !el.hasAttribute('disabled') &&\n        el.tabIndex !== -1\n      );\n    });\n\n    setFocusableElements(visibleElements);\n  }, [focusableSelector]);\n\n  // Focar elemento por índice\n  const focusElementByIndex = useCallback((index: number) => {\n    if (focusableElements.length === 0) return;\n\n    const clampedIndex = Math.max(0, Math.min(index, focusableElements.length - 1));\n    const element = focusableElements[clampedIndex];\n    \n    if (element) {\n      element.focus();\n      setCurrentFocusIndex(clampedIndex);\n    }\n  }, [focusableElements]);\n\n  // Navegar para próximo elemento\n  const focusNext = useCallback(() => {\n    const nextIndex = currentFocusIndex + 1;\n    const targetIndex = nextIndex >= focusableElements.length ? 0 : nextIndex;\n    focusElementByIndex(targetIndex);\n  }, [currentFocusIndex, focusableElements.length, focusElementByIndex]);\n\n  // Navegar para elemento anterior\n  const focusPrevious = useCallback(() => {\n    const prevIndex = currentFocusIndex - 1;\n    const targetIndex = prevIndex < 0 ? focusableElements.length - 1 : prevIndex;\n    focusElementByIndex(targetIndex);\n  }, [currentFocusIndex, focusableElements.length, focusElementByIndex]);\n\n  // Focar primeiro elemento\n  const focusFirst = useCallback(() => {\n    focusElementByIndex(0);\n  }, [focusElementByIndex]);\n\n  // Focar último elemento\n  const focusLast = useCallback(() => {\n    focusElementByIndex(focusableElements.length - 1);\n  }, [focusElementByIndex, focusableElements.length]);\n\n  // Salvar foco anterior\n  const savePreviousFocus = useCallback(() => {\n    previousFocusRef.current = document.activeElement as HTMLElement;\n  }, []);\n\n  // Restaurar foco anterior\n  const restorePreviousFocus = useCallback(() => {\n    if (restoreFocus && previousFocusRef.current) {\n      previousFocusRef.current.focus();\n    }\n  }, [restoreFocus]);\n\n  // Trap de foco\n  const handleFocusTrap = useCallback((event: KeyboardEvent) => {\n    if (!trapFocus || focusableElements.length === 0) return;\n\n    if (event.key === 'Tab') {\n      event.preventDefault();\n      \n      if (event.shiftKey) {\n        focusPrevious();\n      } else {\n        focusNext();\n      }\n    }\n  }, [trapFocus, focusableElements.length, focusNext, focusPrevious]);\n\n  // Configurar trap de foco\n  useEffect(() => {\n    if (trapFocus) {\n      document.addEventListener('keydown', handleFocusTrap);\n      return () => document.removeEventListener('keydown', handleFocusTrap);\n    }\n  }, [trapFocus, handleFocusTrap]);\n\n  // Auto focus\n  useEffect(() => {\n    if (autoFocus && focusableElements.length > 0) {\n      focusFirst();\n    }\n  }, [autoFocus, focusableElements.length, focusFirst]);\n\n  // Atualizar elementos focáveis quando container muda\n  useEffect(() => {\n    updateFocusableElements();\n    \n    // Observer para mudanças no DOM\n    if (containerRef.current) {\n      const observer = new MutationObserver(updateFocusableElements);\n      observer.observe(containerRef.current, {\n        childList: true,\n        subtree: true,\n        attributes: true,\n        attributeFilter: ['disabled', 'tabindex', 'aria-hidden'],\n      });\n      \n      return () => observer.disconnect();\n    }\n  }, [updateFocusableElements]);\n\n  return {\n    containerRef,\n    focusableElements,\n    currentFocusIndex,\n    focusNext,\n    focusPrevious,\n    focusFirst,\n    focusLast,\n    focusElementByIndex,\n    savePreviousFocus,\n    restorePreviousFocus,\n    updateFocusableElements,\n  };\n};\n\n// === HOOK PARA SCREEN READERS ===\nexport const useScreenReader = (options: ScreenReaderOptions = {}) => {\n  const {\n    announceChanges = true,\n    ariaLive = 'polite',\n    atomic = false,\n  } = options;\n\n  const announcementRef = useRef<HTMLDivElement>(null);\n  const [announcement, setAnnouncement] = useState('');\n\n  // Anunciar mensagem\n  const announce = useCallback((message: string, priority: 'polite' | 'assertive' = 'polite') => {\n    if (!announceChanges) return;\n\n    setAnnouncement(message);\n    \n    if (announcementRef.current) {\n      announcementRef.current.setAttribute('aria-live', priority);\n    }\n\n    // Limpar anúncio após um tempo\n    setTimeout(() => {\n      setAnnouncement('');\n    }, 1000);\n  }, [announceChanges]);\n\n  // Anunciar mudança de página\n  const announcePageChange = useCallback((pageTitle: string) => {\n    announce(`Navegou para ${pageTitle}`, 'assertive');\n  }, [announce]);\n\n  // Anunciar erro\n  const announceError = useCallback((error: string) => {\n    announce(`Erro: ${error}`, 'assertive');\n  }, [announce]);\n\n  // Anunciar sucesso\n  const announceSuccess = useCallback((message: string) => {\n    announce(`Sucesso: ${message}`, 'polite');\n  }, [announce]);\n\n  // Anunciar carregamento\n  const announceLoading = useCallback((isLoading: boolean) => {\n    if (isLoading) {\n      announce('Carregando...', 'polite');\n    } else {\n      announce('Carregamento concluído', 'polite');\n    }\n  }, [announce]);\n\n  // Componente de anúncio\n  const AnnouncementRegion = useCallback(() => (\n    <div\n      ref={announcementRef}\n      aria-live={ariaLive}\n      aria-atomic={atomic}\n      className=\"sr-only\"\n      role=\"status\"\n    >\n      {announcement}\n    </div>\n  ), [ariaLive, atomic, announcement]);\n\n  return {\n    announce,\n    announcePageChange,\n    announceError,\n    announceSuccess,\n    announceLoading,\n    AnnouncementRegion,\n  };\n};\n\n// === HOOK PARA SKIP LINKS ===\nexport const useSkipLinks = () => {\n  const skipLinksRef = useRef<HTMLDivElement>(null);\n  const [skipLinks, setSkipLinks] = useState<Array<{ id: string; label: string }>>([]);\n\n  // Adicionar skip link\n  const addSkipLink = useCallback((id: string, label: string) => {\n    setSkipLinks(prev => {\n      const exists = prev.some(link => link.id === id);\n      if (exists) return prev;\n      return [...prev, { id, label }];\n    });\n  }, []);\n\n  // Remover skip link\n  const removeSkipLink = useCallback((id: string) => {\n    setSkipLinks(prev => prev.filter(link => link.id !== id));\n  }, []);\n\n  // Pular para seção\n  const skipToSection = useCallback((id: string) => {\n    const element = document.getElementById(id);\n    if (element) {\n      element.focus();\n      element.scrollIntoView({ behavior: 'smooth', block: 'start' });\n    }\n  }, []);\n\n  // Componente de skip links\n  const SkipLinks = useCallback(() => (\n    <div\n      ref={skipLinksRef}\n      className=\"skip-links fixed top-0 left-0 z-50 -translate-y-full focus-within:translate-y-0 transition-transform\"\n    >\n      {skipLinks.map(({ id, label }) => (\n        <button\n          key={id}\n          onClick={() => skipToSection(id)}\n          className=\"block bg-primary text-primary-foreground px-4 py-2 text-sm font-medium focus:outline-none focus:ring-2 focus:ring-ring\"\n        >\n          Pular para {label}\n        </button>\n      ))}\n    </div>\n  ), [skipLinks, skipToSection]);\n\n  return {\n    addSkipLink,\n    removeSkipLink,\n    skipToSection,\n    SkipLinks,\n  };\n};\n\n// === HOOK PARA ARIA ATTRIBUTES ===\nexport const useAriaAttributes = () => {\n  // Gerar ID único para ARIA\n  const generateAriaId = useCallback((prefix: string = 'aria') => {\n    return `${prefix}-${Math.random().toString(36).substr(2, 9)}`;\n  }, []);\n\n  // Criar atributos para combobox\n  const createComboboxAttributes = useCallback(({\n    isExpanded,\n    hasPopup = true,\n    controls,\n    activeDescendant,\n  }: {\n    isExpanded: boolean;\n    hasPopup?: boolean;\n    controls?: string;\n    activeDescendant?: string;\n  }) => {\n    return {\n      role: 'combobox',\n      'aria-expanded': isExpanded,\n      'aria-haspopup': hasPopup,\n      ...(controls && { 'aria-controls': controls }),\n      ...(activeDescendant && { 'aria-activedescendant': activeDescendant }),\n    };\n  }, []);\n\n  // Criar atributos para listbox\n  const createListboxAttributes = useCallback(({\n    multiselectable = false,\n    orientation = 'vertical',\n    labelledBy,\n  }: {\n    multiselectable?: boolean;\n    orientation?: 'vertical' | 'horizontal';\n    labelledBy?: string;\n  } = {}) => {\n    return {\n      role: 'listbox',\n      'aria-multiselectable': multiselectable,\n      'aria-orientation': orientation,\n      ...(labelledBy && { 'aria-labelledby': labelledBy }),\n    };\n  }, []);\n\n  // Criar atributos para option\n  const createOptionAttributes = useCallback(({\n    selected = false,\n    disabled = false,\n    setSize,\n    posInSet,\n  }: {\n    selected?: boolean;\n    disabled?: boolean;\n    setSize?: number;\n    posInSet?: number;\n  } = {}) => {\n    return {\n      role: 'option',\n      'aria-selected': selected,\n      'aria-disabled': disabled,\n      ...(setSize && { 'aria-setsize': setSize }),\n      ...(posInSet && { 'aria-posinset': posInSet }),\n    };\n  }, []);\n\n  // Criar atributos para dialog\n  const createDialogAttributes = useCallback(({\n    labelledBy,\n    describedBy,\n    modal = true,\n  }: {\n    labelledBy?: string;\n    describedBy?: string;\n    modal?: boolean;\n  } = {}) => {\n    return {\n      role: 'dialog',\n      'aria-modal': modal,\n      ...(labelledBy && { 'aria-labelledby': labelledBy }),\n      ...(describedBy && { 'aria-describedby': describedBy }),\n    };\n  }, []);\n\n  // Criar atributos para button\n  const createButtonAttributes = useCallback(({\n    pressed,\n    expanded,\n    controls,\n    describedBy,\n    disabled = false,\n  }: {\n    pressed?: boolean;\n    expanded?: boolean;\n    controls?: string;\n    describedBy?: string;\n    disabled?: boolean;\n  } = {}) => {\n    return {\n      type: 'button' as const,\n      'aria-disabled': disabled,\n      ...(pressed !== undefined && { 'aria-pressed': pressed }),\n      ...(expanded !== undefined && { 'aria-expanded': expanded }),\n      ...(controls && { 'aria-controls': controls }),\n      ...(describedBy && { 'aria-describedby': describedBy }),\n    };\n  }, []);\n\n  return {\n    generateAriaId,\n    createComboboxAttributes,\n    createListboxAttributes,\n    createOptionAttributes,\n    createDialogAttributes,\n    createButtonAttributes,\n  };\n};\n\n// === HOOK PARA DETECÇÃO DE PREFERÊNCIAS ===\nexport const useAccessibilityPreferences = () => {\n  const [preferences, setPreferences] = useState({\n    prefersReducedMotion: false,\n    prefersHighContrast: false,\n    prefersColorScheme: 'light' as 'light' | 'dark',\n  });\n\n  useEffect(() => {\n    // Detectar preferência de movimento reduzido\n    const motionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    const updateMotionPreference = () => {\n      setPreferences(prev => ({\n        ...prev,\n        prefersReducedMotion: motionQuery.matches,\n      }));\n    };\n    \n    updateMotionPreference();\n    motionQuery.addEventListener('change', updateMotionPreference);\n\n    // Detectar preferência de alto contraste\n    const contrastQuery = window.matchMedia('(prefers-contrast: high)');\n    const updateContrastPreference = () => {\n      setPreferences(prev => ({\n        ...prev,\n        prefersHighContrast: contrastQuery.matches,\n      }));\n    };\n    \n    updateContrastPreference();\n    contrastQuery.addEventListener('change', updateContrastPreference);\n\n    // Detectar preferência de esquema de cores\n    const colorSchemeQuery = window.matchMedia('(prefers-color-scheme: dark)');\n    const updateColorSchemePreference = () => {\n      setPreferences(prev => ({\n        ...prev,\n        prefersColorScheme: colorSchemeQuery.matches ? 'dark' : 'light',\n      }));\n    };\n    \n    updateColorSchemePreference();\n    colorSchemeQuery.addEventListener('change', updateColorSchemePreference);\n\n    return () => {\n      motionQuery.removeEventListener('change', updateMotionPreference);\n      contrastQuery.removeEventListener('change', updateContrastPreference);\n      colorSchemeQuery.removeEventListener('change', updateColorSchemePreference);\n    };\n  }, []);\n\n  return preferences;\n};\n\n// === TIPOS EXPORTADOS ===\nexport type {\n  KeyboardNavigationOptions,\n  FocusManagementOptions,\n  ScreenReaderOptions,\n};"