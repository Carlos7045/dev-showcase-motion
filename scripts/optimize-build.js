#!/usr/bin/env node\n\n/**\n * Build Optimization Script\n * Script para otimizar o build de produção\n */\n\nconst fs = require('fs');\nconst path = require('path');\nconst { execSync } = require('child_process');\nconst { gzipSync, brotliCompressSync } = require('zlib');\n\n// === CONFIGURAÇÕES ===\nconst CONFIG = {\n  distDir: 'dist',\n  statsFile: 'dist/stats.json',\n  reportFile: 'dist/build-report.md',\n  thresholds: {\n    maxBundleSize: 2 * 1024 * 1024, // 2MB\n    maxChunkSize: 500 * 1024,       // 500KB\n    maxAssetSize: 1024 * 1024,      // 1MB\n  },\n};\n\n// === UTILITÁRIOS ===\nconst formatBytes = (bytes) => {\n  if (bytes === 0) return '0 B';\n  const k = 1024;\n  const sizes = ['B', 'KB', 'MB', 'GB'];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n};\n\nconst log = {\n  info: (msg) => console.log(`ℹ️  ${msg}`),\n  success: (msg) => console.log(`✅ ${msg}`),\n  warning: (msg) => console.log(`⚠️  ${msg}`),\n  error: (msg) => console.log(`❌ ${msg}`),\n  step: (msg) => console.log(`🔄 ${msg}`),\n};\n\n// === FUNÇÕES PRINCIPAIS ===\n\n// Executar build\nconst runBuild = () => {\n  log.step('Executando build de produção...');\n  \n  try {\n    // Limpar dist\n    if (fs.existsSync(CONFIG.distDir)) {\n      execSync(`rm -rf ${CONFIG.distDir}`, { stdio: 'inherit' });\n    }\n    \n    // Executar build\n    execSync('npm run build', { stdio: 'inherit' });\n    log.success('Build concluído com sucesso!');\n  } catch (error) {\n    log.error('Falha no build:');\n    console.error(error.message);\n    process.exit(1);\n  }\n};\n\n// Analisar arquivos do build\nconst analyzeBuild = () => {\n  log.step('Analisando arquivos do build...');\n  \n  const distPath = path.resolve(CONFIG.distDir);\n  \n  if (!fs.existsSync(distPath)) {\n    log.error('Diretório dist não encontrado!');\n    return null;\n  }\n  \n  const analysis = {\n    totalSize: 0,\n    totalGzipSize: 0,\n    totalBrotliSize: 0,\n    files: [],\n    chunks: [],\n    assets: [],\n  };\n  \n  // Analisar recursivamente\n  const analyzeDirectory = (dir, relativePath = '') => {\n    const items = fs.readdirSync(dir);\n    \n    items.forEach(item => {\n      const fullPath = path.join(dir, item);\n      const relativeFilePath = path.join(relativePath, item);\n      const stat = fs.statSync(fullPath);\n      \n      if (stat.isDirectory()) {\n        analyzeDirectory(fullPath, relativeFilePath);\n      } else {\n        const content = fs.readFileSync(fullPath);\n        const size = stat.size;\n        const gzipSize = gzipSync(content).length;\n        const brotliSize = brotliCompressSync(content).length;\n        \n        const fileInfo = {\n          name: relativeFilePath,\n          size,\n          gzipSize,\n          brotliSize,\n          type: getFileType(item),\n        };\n        \n        analysis.files.push(fileInfo);\n        analysis.totalSize += size;\n        analysis.totalGzipSize += gzipSize;\n        analysis.totalBrotliSize += brotliSize;\n        \n        // Categorizar arquivos\n        if (item.includes('chunk') || item.endsWith('.js')) {\n          analysis.chunks.push(fileInfo);\n        } else {\n          analysis.assets.push(fileInfo);\n        }\n      }\n    });\n  };\n  \n  analyzeDirectory(distPath);\n  \n  return analysis;\n};\n\n// Determinar tipo de arquivo\nconst getFileType = (filename) => {\n  const ext = path.extname(filename).toLowerCase();\n  \n  if (['.js', '.mjs'].includes(ext)) return 'javascript';\n  if (['.css'].includes(ext)) return 'stylesheet';\n  if (['.png', '.jpg', '.jpeg', '.gif', '.svg', '.webp'].includes(ext)) return 'image';\n  if (['.woff', '.woff2', '.ttf', '.eot', '.otf'].includes(ext)) return 'font';\n  if (['.html'].includes(ext)) return 'html';\n  \n  return 'other';\n};\n\n// Verificar thresholds\nconst checkThresholds = (analysis) => {\n  log.step('Verificando thresholds de performance...');\n  \n  const issues = [];\n  const warnings = [];\n  \n  // Verificar tamanho total\n  if (analysis.totalGzipSize > CONFIG.thresholds.maxBundleSize) {\n    issues.push(`Bundle total muito grande: ${formatBytes(analysis.totalGzipSize)} (limite: ${formatBytes(CONFIG.thresholds.maxBundleSize)})`);\n  }\n  \n  // Verificar chunks individuais\n  analysis.chunks.forEach(chunk => {\n    if (chunk.gzipSize > CONFIG.thresholds.maxChunkSize) {\n      issues.push(`Chunk muito grande: ${chunk.name} - ${formatBytes(chunk.gzipSize)} (limite: ${formatBytes(CONFIG.thresholds.maxChunkSize)})`);\n    }\n  });\n  \n  // Verificar assets individuais\n  analysis.assets.forEach(asset => {\n    if (asset.gzipSize > CONFIG.thresholds.maxAssetSize) {\n      warnings.push(`Asset grande: ${asset.name} - ${formatBytes(asset.gzipSize)}`);\n    }\n  });\n  \n  return { issues, warnings };\n};\n\n// Gerar relatório\nconst generateReport = (analysis, thresholdCheck) => {\n  log.step('Gerando relatório de build...');\n  \n  const report = [];\n  \n  // Cabeçalho\n  report.push('# Build Analysis Report');\n  report.push('');\n  report.push(`**Data**: ${new Date().toISOString()}`);\n  report.push('');\n  \n  // Resumo\n  report.push('## Resumo');\n  report.push('');\n  report.push(`- **Arquivos**: ${analysis.files.length}`);\n  report.push(`- **Tamanho Total**: ${formatBytes(analysis.totalSize)}`);\n  report.push(`- **Tamanho Gzip**: ${formatBytes(analysis.totalGzipSize)}`);\n  report.push(`- **Tamanho Brotli**: ${formatBytes(analysis.totalBrotliSize)}`);\n  report.push(`- **Compressão Gzip**: ${((1 - analysis.totalGzipSize / analysis.totalSize) * 100).toFixed(1)}%`);\n  report.push(`- **Compressão Brotli**: ${((1 - analysis.totalBrotliSize / analysis.totalSize) * 100).toFixed(1)}%`);\n  report.push('');\n  \n  // Chunks\n  if (analysis.chunks.length > 0) {\n    report.push('## JavaScript Chunks');\n    report.push('');\n    report.push('| Arquivo | Tamanho | Gzip | Brotli |');\n    report.push('|---------|---------|------|--------|');\n    \n    analysis.chunks\n      .sort((a, b) => b.gzipSize - a.gzipSize)\n      .forEach(chunk => {\n        report.push(`| ${chunk.name} | ${formatBytes(chunk.size)} | ${formatBytes(chunk.gzipSize)} | ${formatBytes(chunk.brotliSize)} |`);\n      });\n    \n    report.push('');\n  }\n  \n  // Assets por tipo\n  const assetsByType = analysis.assets.reduce((acc, asset) => {\n    if (!acc[asset.type]) {\n      acc[asset.type] = { count: 0, size: 0, gzipSize: 0 };\n    }\n    acc[asset.type].count++;\n    acc[asset.type].size += asset.size;\n    acc[asset.type].gzipSize += asset.gzipSize;\n    return acc;\n  }, {});\n  \n  if (Object.keys(assetsByType).length > 0) {\n    report.push('## Assets por Tipo');\n    report.push('');\n    report.push('| Tipo | Quantidade | Tamanho | Gzip |');\n    report.push('|------|------------|---------|------|');\n    \n    Object.entries(assetsByType).forEach(([type, data]) => {\n      report.push(`| ${type} | ${data.count} | ${formatBytes(data.size)} | ${formatBytes(data.gzipSize)} |`);\n    });\n    \n    report.push('');\n  }\n  \n  // Issues e warnings\n  if (thresholdCheck.issues.length > 0) {\n    report.push('## ❌ Issues');\n    report.push('');\n    thresholdCheck.issues.forEach(issue => {\n      report.push(`- ${issue}`);\n    });\n    report.push('');\n  }\n  \n  if (thresholdCheck.warnings.length > 0) {\n    report.push('## ⚠️ Warnings');\n    report.push('');\n    thresholdCheck.warnings.forEach(warning => {\n      report.push(`- ${warning}`);\n    });\n    report.push('');\n  }\n  \n  // Recomendações\n  report.push('## 💡 Recomendações');\n  report.push('');\n  \n  if (analysis.totalGzipSize > 1024 * 1024) { // > 1MB\n    report.push('- Considere implementar code splitting mais agressivo');\n    report.push('- Analise dependências grandes e considere alternativas menores');\n  }\n  \n  const largeChunks = analysis.chunks.filter(c => c.gzipSize > 200 * 1024);\n  if (largeChunks.length > 0) {\n    report.push('- Divida chunks grandes em chunks menores');\n  }\n  \n  const imageAssets = analysis.assets.filter(a => a.type === 'image');\n  if (imageAssets.length > 0) {\n    const totalImageSize = imageAssets.reduce((sum, img) => sum + img.size, 0);\n    if (totalImageSize > 500 * 1024) {\n      report.push('- Otimize imagens (WebP, compressão, lazy loading)');\n    }\n  }\n  \n  if (thresholdCheck.issues.length === 0 && thresholdCheck.warnings.length === 0) {\n    report.push('- ✅ Build otimizado! Considere implementar service worker para cache.');\n  }\n  \n  return report.join('\\n');\n};\n\n// Otimizar arquivos\nconst optimizeFiles = (analysis) => {\n  log.step('Aplicando otimizações...');\n  \n  let optimizations = 0;\n  \n  // Gerar arquivos comprimidos\n  analysis.files.forEach(file => {\n    const fullPath = path.join(CONFIG.distDir, file.name);\n    \n    if (file.type === 'javascript' || file.type === 'stylesheet') {\n      const content = fs.readFileSync(fullPath);\n      \n      // Gzip\n      const gzipPath = fullPath + '.gz';\n      if (!fs.existsSync(gzipPath)) {\n        fs.writeFileSync(gzipPath, gzipSync(content));\n        optimizations++;\n      }\n      \n      // Brotli\n      const brotliPath = fullPath + '.br';\n      if (!fs.existsSync(brotliPath)) {\n        fs.writeFileSync(brotliPath, brotliCompressSync(content));\n        optimizations++;\n      }\n    }\n  });\n  \n  log.success(`${optimizations} arquivos comprimidos gerados`);\n};\n\n// Salvar relatório\nconst saveReport = (report) => {\n  fs.writeFileSync(CONFIG.reportFile, report);\n  log.success(`Relatório salvo em ${CONFIG.reportFile}`);\n};\n\n// === EXECUÇÃO PRINCIPAL ===\nconst main = () => {\n  console.log('🚀 Iniciando otimização de build...\\n');\n  \n  try {\n    // 1. Executar build\n    runBuild();\n    \n    // 2. Analisar build\n    const analysis = analyzeBuild();\n    if (!analysis) {\n      process.exit(1);\n    }\n    \n    // 3. Verificar thresholds\n    const thresholdCheck = checkThresholds(analysis);\n    \n    // 4. Otimizar arquivos\n    optimizeFiles(analysis);\n    \n    // 5. Gerar e salvar relatório\n    const report = generateReport(analysis, thresholdCheck);\n    saveReport(report);\n    \n    // 6. Exibir resumo\n    console.log('\\n📊 Resumo do Build:');\n    console.log(`   Tamanho Total: ${formatBytes(analysis.totalSize)}`);\n    console.log(`   Tamanho Gzip: ${formatBytes(analysis.totalGzipSize)}`);\n    console.log(`   Compressão: ${((1 - analysis.totalGzipSize / analysis.totalSize) * 100).toFixed(1)}%`);\n    \n    if (thresholdCheck.issues.length > 0) {\n      console.log(`\\n❌ ${thresholdCheck.issues.length} issue(s) encontrado(s)`);\n      thresholdCheck.issues.forEach(issue => log.error(issue));\n      process.exit(1);\n    }\n    \n    if (thresholdCheck.warnings.length > 0) {\n      console.log(`\\n⚠️  ${thresholdCheck.warnings.length} warning(s)`);\n      thresholdCheck.warnings.forEach(warning => log.warning(warning));\n    }\n    \n    console.log('\\n✅ Build otimizado com sucesso!');\n    \n  } catch (error) {\n    log.error('Erro durante otimização:');\n    console.error(error);\n    process.exit(1);\n  }\n};\n\n// Executar se chamado diretamente\nif (require.main === module) {\n  main();\n}\n\nmodule.exports = {\n  runBuild,\n  analyzeBuild,\n  checkThresholds,\n  generateReport,\n  optimizeFiles,\n};"