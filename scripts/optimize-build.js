#!/usr/bin/env node\n\n/**\n * Build Optimization Script\n * Script para otimizar o build de produÃ§Ã£o\n */\n\nconst fs = require('fs');\nconst path = require('path');\nconst { execSync } = require('child_process');\nconst { gzipSync, brotliCompressSync } = require('zlib');\n\n// === CONFIGURAÃ‡Ã•ES ===\nconst CONFIG = {\n  distDir: 'dist',\n  statsFile: 'dist/stats.json',\n  reportFile: 'dist/build-report.md',\n  thresholds: {\n    maxBundleSize: 2 * 1024 * 1024, // 2MB\n    maxChunkSize: 500 * 1024,       // 500KB\n    maxAssetSize: 1024 * 1024,      // 1MB\n  },\n};\n\n// === UTILITÃRIOS ===\nconst formatBytes = (bytes) => {\n  if (bytes === 0) return '0 B';\n  const k = 1024;\n  const sizes = ['B', 'KB', 'MB', 'GB'];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n};\n\nconst log = {\n  info: (msg) => console.log(`â„¹ï¸  ${msg}`),\n  success: (msg) => console.log(`âœ… ${msg}`),\n  warning: (msg) => console.log(`âš ï¸  ${msg}`),\n  error: (msg) => console.log(`âŒ ${msg}`),\n  step: (msg) => console.log(`ðŸ”„ ${msg}`),\n};\n\n// === FUNÃ‡Ã•ES PRINCIPAIS ===\n\n// Executar build\nconst runBuild = () => {\n  log.step('Executando build de produÃ§Ã£o...');\n  \n  try {\n    // Limpar dist\n    if (fs.existsSync(CONFIG.distDir)) {\n      execSync(`rm -rf ${CONFIG.distDir}`, { stdio: 'inherit' });\n    }\n    \n    // Executar build\n    execSync('npm run build', { stdio: 'inherit' });\n    log.success('Build concluÃ­do com sucesso!');\n  } catch (error) {\n    log.error('Falha no build:');\n    console.error(error.message);\n    process.exit(1);\n  }\n};\n\n// Analisar arquivos do build\nconst analyzeBuild = () => {\n  log.step('Analisando arquivos do build...');\n  \n  const distPath = path.resolve(CONFIG.distDir);\n  \n  if (!fs.existsSync(distPath)) {\n    log.error('DiretÃ³rio dist nÃ£o encontrado!');\n    return null;\n  }\n  \n  const analysis = {\n    totalSize: 0,\n    totalGzipSize: 0,\n    totalBrotliSize: 0,\n    files: [],\n    chunks: [],\n    assets: [],\n  };\n  \n  // Analisar recursivamente\n  const analyzeDirectory = (dir, relativePath = '') => {\n    const items = fs.readdirSync(dir);\n    \n    items.forEach(item => {\n      const fullPath = path.join(dir, item);\n      const relativeFilePath = path.join(relativePath, item);\n      const stat = fs.statSync(fullPath);\n      \n      if (stat.isDirectory()) {\n        analyzeDirectory(fullPath, relativeFilePath);\n      } else {\n        const content = fs.readFileSync(fullPath);\n        const size = stat.size;\n        const gzipSize = gzipSync(content).length;\n        const brotliSize = brotliCompressSync(content).length;\n        \n        const fileInfo = {\n          name: relativeFilePath,\n          size,\n          gzipSize,\n          brotliSize,\n          type: getFileType(item),\n        };\n        \n        analysis.files.push(fileInfo);\n        analysis.totalSize += size;\n        analysis.totalGzipSize += gzipSize;\n        analysis.totalBrotliSize += brotliSize;\n        \n        // Categorizar arquivos\n        if (item.includes('chunk') || item.endsWith('.js')) {\n          analysis.chunks.push(fileInfo);\n        } else {\n          analysis.assets.push(fileInfo);\n        }\n      }\n    });\n  };\n  \n  analyzeDirectory(distPath);\n  \n  return analysis;\n};\n\n// Determinar tipo de arquivo\nconst getFileType = (filename) => {\n  const ext = path.extname(filename).toLowerCase();\n  \n  if (['.js', '.mjs'].includes(ext)) return 'javascript';\n  if (['.css'].includes(ext)) return 'stylesheet';\n  if (['.png', '.jpg', '.jpeg', '.gif', '.svg', '.webp'].includes(ext)) return 'image';\n  if (['.woff', '.woff2', '.ttf', '.eot', '.otf'].includes(ext)) return 'font';\n  if (['.html'].includes(ext)) return 'html';\n  \n  return 'other';\n};\n\n// Verificar thresholds\nconst checkThresholds = (analysis) => {\n  log.step('Verificando thresholds de performance...');\n  \n  const issues = [];\n  const warnings = [];\n  \n  // Verificar tamanho total\n  if (analysis.totalGzipSize > CONFIG.thresholds.maxBundleSize) {\n    issues.push(`Bundle total muito grande: ${formatBytes(analysis.totalGzipSize)} (limite: ${formatBytes(CONFIG.thresholds.maxBundleSize)})`);\n  }\n  \n  // Verificar chunks individuais\n  analysis.chunks.forEach(chunk => {\n    if (chunk.gzipSize > CONFIG.thresholds.maxChunkSize) {\n      issues.push(`Chunk muito grande: ${chunk.name} - ${formatBytes(chunk.gzipSize)} (limite: ${formatBytes(CONFIG.thresholds.maxChunkSize)})`);\n    }\n  });\n  \n  // Verificar assets individuais\n  analysis.assets.forEach(asset => {\n    if (asset.gzipSize > CONFIG.thresholds.maxAssetSize) {\n      warnings.push(`Asset grande: ${asset.name} - ${formatBytes(asset.gzipSize)}`);\n    }\n  });\n  \n  return { issues, warnings };\n};\n\n// Gerar relatÃ³rio\nconst generateReport = (analysis, thresholdCheck) => {\n  log.step('Gerando relatÃ³rio de build...');\n  \n  const report = [];\n  \n  // CabeÃ§alho\n  report.push('# Build Analysis Report');\n  report.push('');\n  report.push(`**Data**: ${new Date().toISOString()}`);\n  report.push('');\n  \n  // Resumo\n  report.push('## Resumo');\n  report.push('');\n  report.push(`- **Arquivos**: ${analysis.files.length}`);\n  report.push(`- **Tamanho Total**: ${formatBytes(analysis.totalSize)}`);\n  report.push(`- **Tamanho Gzip**: ${formatBytes(analysis.totalGzipSize)}`);\n  report.push(`- **Tamanho Brotli**: ${formatBytes(analysis.totalBrotliSize)}`);\n  report.push(`- **CompressÃ£o Gzip**: ${((1 - analysis.totalGzipSize / analysis.totalSize) * 100).toFixed(1)}%`);\n  report.push(`- **CompressÃ£o Brotli**: ${((1 - analysis.totalBrotliSize / analysis.totalSize) * 100).toFixed(1)}%`);\n  report.push('');\n  \n  // Chunks\n  if (analysis.chunks.length > 0) {\n    report.push('## JavaScript Chunks');\n    report.push('');\n    report.push('| Arquivo | Tamanho | Gzip | Brotli |');\n    report.push('|---------|---------|------|--------|');\n    \n    analysis.chunks\n      .sort((a, b) => b.gzipSize - a.gzipSize)\n      .forEach(chunk => {\n        report.push(`| ${chunk.name} | ${formatBytes(chunk.size)} | ${formatBytes(chunk.gzipSize)} | ${formatBytes(chunk.brotliSize)} |`);\n      });\n    \n    report.push('');\n  }\n  \n  // Assets por tipo\n  const assetsByType = analysis.assets.reduce((acc, asset) => {\n    if (!acc[asset.type]) {\n      acc[asset.type] = { count: 0, size: 0, gzipSize: 0 };\n    }\n    acc[asset.type].count++;\n    acc[asset.type].size += asset.size;\n    acc[asset.type].gzipSize += asset.gzipSize;\n    return acc;\n  }, {});\n  \n  if (Object.keys(assetsByType).length > 0) {\n    report.push('## Assets por Tipo');\n    report.push('');\n    report.push('| Tipo | Quantidade | Tamanho | Gzip |');\n    report.push('|------|------------|---------|------|');\n    \n    Object.entries(assetsByType).forEach(([type, data]) => {\n      report.push(`| ${type} | ${data.count} | ${formatBytes(data.size)} | ${formatBytes(data.gzipSize)} |`);\n    });\n    \n    report.push('');\n  }\n  \n  // Issues e warnings\n  if (thresholdCheck.issues.length > 0) {\n    report.push('## âŒ Issues');\n    report.push('');\n    thresholdCheck.issues.forEach(issue => {\n      report.push(`- ${issue}`);\n    });\n    report.push('');\n  }\n  \n  if (thresholdCheck.warnings.length > 0) {\n    report.push('## âš ï¸ Warnings');\n    report.push('');\n    thresholdCheck.warnings.forEach(warning => {\n      report.push(`- ${warning}`);\n    });\n    report.push('');\n  }\n  \n  // RecomendaÃ§Ãµes\n  report.push('## ðŸ’¡ RecomendaÃ§Ãµes');\n  report.push('');\n  \n  if (analysis.totalGzipSize > 1024 * 1024) { // > 1MB\n    report.push('- Considere implementar code splitting mais agressivo');\n    report.push('- Analise dependÃªncias grandes e considere alternativas menores');\n  }\n  \n  const largeChunks = analysis.chunks.filter(c => c.gzipSize > 200 * 1024);\n  if (largeChunks.length > 0) {\n    report.push('- Divida chunks grandes em chunks menores');\n  }\n  \n  const imageAssets = analysis.assets.filter(a => a.type === 'image');\n  if (imageAssets.length > 0) {\n    const totalImageSize = imageAssets.reduce((sum, img) => sum + img.size, 0);\n    if (totalImageSize > 500 * 1024) {\n      report.push('- Otimize imagens (WebP, compressÃ£o, lazy loading)');\n    }\n  }\n  \n  if (thresholdCheck.issues.length === 0 && thresholdCheck.warnings.length === 0) {\n    report.push('- âœ… Build otimizado! Considere implementar service worker para cache.');\n  }\n  \n  return report.join('\\n');\n};\n\n// Otimizar arquivos\nconst optimizeFiles = (analysis) => {\n  log.step('Aplicando otimizaÃ§Ãµes...');\n  \n  let optimizations = 0;\n  \n  // Gerar arquivos comprimidos\n  analysis.files.forEach(file => {\n    const fullPath = path.join(CONFIG.distDir, file.name);\n    \n    if (file.type === 'javascript' || file.type === 'stylesheet') {\n      const content = fs.readFileSync(fullPath);\n      \n      // Gzip\n      const gzipPath = fullPath + '.gz';\n      if (!fs.existsSync(gzipPath)) {\n        fs.writeFileSync(gzipPath, gzipSync(content));\n        optimizations++;\n      }\n      \n      // Brotli\n      const brotliPath = fullPath + '.br';\n      if (!fs.existsSync(brotliPath)) {\n        fs.writeFileSync(brotliPath, brotliCompressSync(content));\n        optimizations++;\n      }\n    }\n  });\n  \n  log.success(`${optimizations} arquivos comprimidos gerados`);\n};\n\n// Salvar relatÃ³rio\nconst saveReport = (report) => {\n  fs.writeFileSync(CONFIG.reportFile, report);\n  log.success(`RelatÃ³rio salvo em ${CONFIG.reportFile}`);\n};\n\n// === EXECUÃ‡ÃƒO PRINCIPAL ===\nconst main = () => {\n  console.log('ðŸš€ Iniciando otimizaÃ§Ã£o de build...\\n');\n  \n  try {\n    // 1. Executar build\n    runBuild();\n    \n    // 2. Analisar build\n    const analysis = analyzeBuild();\n    if (!analysis) {\n      process.exit(1);\n    }\n    \n    // 3. Verificar thresholds\n    const thresholdCheck = checkThresholds(analysis);\n    \n    // 4. Otimizar arquivos\n    optimizeFiles(analysis);\n    \n    // 5. Gerar e salvar relatÃ³rio\n    const report = generateReport(analysis, thresholdCheck);\n    saveReport(report);\n    \n    // 6. Exibir resumo\n    console.log('\\nðŸ“Š Resumo do Build:');\n    console.log(`   Tamanho Total: ${formatBytes(analysis.totalSize)}`);\n    console.log(`   Tamanho Gzip: ${formatBytes(analysis.totalGzipSize)}`);\n    console.log(`   CompressÃ£o: ${((1 - analysis.totalGzipSize / analysis.totalSize) * 100).toFixed(1)}%`);\n    \n    if (thresholdCheck.issues.length > 0) {\n      console.log(`\\nâŒ ${thresholdCheck.issues.length} issue(s) encontrado(s)`);\n      thresholdCheck.issues.forEach(issue => log.error(issue));\n      process.exit(1);\n    }\n    \n    if (thresholdCheck.warnings.length > 0) {\n      console.log(`\\nâš ï¸  ${thresholdCheck.warnings.length} warning(s)`);\n      thresholdCheck.warnings.forEach(warning => log.warning(warning));\n    }\n    \n    console.log('\\nâœ… Build otimizado com sucesso!');\n    \n  } catch (error) {\n    log.error('Erro durante otimizaÃ§Ã£o:');\n    console.error(error);\n    process.exit(1);\n  }\n};\n\n// Executar se chamado diretamente\nif (require.main === module) {\n  main();\n}\n\nmodule.exports = {\n  runBuild,\n  analyzeBuild,\n  checkThresholds,\n  generateReport,\n  optimizeFiles,\n};"